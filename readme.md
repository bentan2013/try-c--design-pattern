Refer to iuhsihsow 的[设计模式专栏](http://blog.csdn.net/column/details/baadf00df00dabadfds0.html)


<table border="2" cellspacing="0" cellpadding="6" rules="groups" frame="hsides">


<colgroup>
<col  class="left" />

<col  class="left" />
</colgroup>
<thead>
<tr>
<th scope="col" class="left">名称</th>
<th scope="col" class="left">blog link</th>
</tr>
</thead>
<tbody>
<tr>
<td class="left">前言</td>
<td class="left"><a href="http://blog.csdn.net/uninterrupted/article/details/53020650">前言</a></td>
</tr>

<tr>
<td class="left">Abstract Factory</td>
<td class="left"><a href="http://blog.csdn.net/uninterrupted/article/details/8471116">抽象工厂模式</a></td>
</tr>

<tr>
<td class="left">Adapter</td>
<td class="left"><a href="http://blog.csdn.net/uninterrupted/article/details/8560206">适配器模式</a></td>
</tr>

<tr>
<td class="left">Bridge</td>
<td class="left"><a href="http://blog.csdn.net/uninterrupted/article/details/8561926">桥接模式</a></td>
</tr>

<tr>
<td class="left">Builder</td>
<td class="left"><a href="http://blog.csdn.net/uninterrupted/article/details/8289329">建造者模式</a></td>
</tr>

<tr>
<td class="left">Chain Of Responsibility</td>
<td class="left">职责链模式</td>
</tr>

<tr>
<td class="left">Command</td>
<td class="left"><a href="http://blog.csdn.net/uninterrupted/article/details/8561461">命令模式</a></td>
</tr>

<tr>
<td class="left">Composite</td>
<td class="left"><a href="http://blog.csdn.net/uninterrupted/article/details/8561341">组合模式</a></td>
</tr>

<tr>
<td class="left">Decorator</td>
<td class="left"><a href="http://blog.csdn.net/uninterrupted/article/details/8235346">装饰模式</a></td>
</tr>

<tr>
<td class="left">Facade</td>
<td class="left"><a href="http://blog.csdn.net/uninterrupted/article/details/8285117">外观模式</a></td>
</tr>

<tr>
<td class="left">Factory Method</td>
<td class="left">工厂方法模式</td>
</tr>

<tr>
<td class="left">Flyweight</td>
<td class="left"><a href="http://blog.csdn.net/uninterrupted/article/details/8634560">享元模式</a></td>
</tr>

<tr>
<td class="left">Interpreter</td>
<td class="left"><a href="http://blog.csdn.net/uninterrupted/article/details/8656727">解释器模式</a></td>
</tr>

<tr>
<td class="left">Iterator</td>
<td class="left"><a href="http://blog.csdn.net/uninterrupted/article/details/8561373">迭代器模式</a></td>
</tr>

<tr>
<td class="left">Mediator</td>
<td class="left">中介者模式</td>
</tr>

<tr>
<td class="left">Memento</td>
<td class="left"><a href="http://blog.csdn.net/uninterrupted/article/details/8561190">备忘录模式</a></td>
</tr>

<tr>
<td class="left">Observer</td>
<td class="left">观察者模式：<a href="http://blog.csdn.net/uninterrupted/article/details/8296456">上</a>，<a href="http://blog.csdn.net/uninterrupted/article/details/8299463">下</a></td>
</tr>

<tr>
<td class="left">Prototype</td>
<td class="left"><a href="http://blog.csdn.net/uninterrupted/article/details/8269021">原型模式</a></td>
</tr>

<tr>
<td class="left">State</td>
<td class="left"><a href="http://blog.csdn.net/uninterrupted/article/details/8560081">状态模式</a></td>
</tr>

<tr>
<td class="left">Strategy</td>
<td class="left"><a href="http://blog.csdn.net/uninterrupted/article/details/8237190">策略模式</a></td>
</tr>

<tr>
<td class="left">Simple factory</td>
<td class="left"><a href="http://blog.csdn.net/uninterrupted/article/details/8237201">简单类工厂</a></td>
</tr>

<tr>
<td class="left">Singleton</td>
<td class="left"><a href="http://blog.csdn.net/uninterrupted/article/details/8561385">单例模式</a></td>
</tr>

<tr>
<td class="left">Template Method</td>
<td class="left"><a href="http://blog.csdn.net/uninterrupted/article/details/8282495">模板方法</a></td>
</tr>

<tr>
<td class="left">Visitor</td>
<td class="left"><a href="http://blog.csdn.net/uninterrupted/article/details/8657906">访问者模式</a></td>
</tr>

<tr>
<td class="left">Proxy</td>
<td class="left"><a href="http://blog.csdn.net/uninterrupted/article/details/8237169">代理模式</a></td>
</tr>
</tbody>
</table>
